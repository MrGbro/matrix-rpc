package io.homeey.matrix.rpc.proxy.cglib;

import io.homeey.matrix.rpc.core.Invocation;
import io.homeey.matrix.rpc.core.Invoker;
import io.homeey.matrix.rpc.core.Result;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * CGLIB 代理工厂测试
 * 
 * @author Matrix RPC Team
 */
public class CglibProxyFactoryTest {
    
    private CglibProxyFactory factory;
    
    @BeforeEach
    public void setup() {
        factory = new CglibProxyFactory();
    }
    
    /**
     * 测试基本代理功能
     */
    @Test
    public void testBasicProxy() {
        // 创建 Mock Invoker
        Invoker<TestService> invoker = createMockInvoker("echo: ");
        
        // 创建代理
        TestService proxy = factory.getProxy(invoker);
        
        // 验证调用
        assertNotNull(proxy, "Proxy should not be null");
        String result = proxy.echo("hello");
        assertEquals("echo: hello", result, "Proxy should invoke correctly");
        
        // 验证代理类名包含 CGLIB
        assertTrue(proxy.getClass().getName().contains("CGLIB"), 
            "Proxy class should be generated by CGLIB");
    }
    
    /**
     * 测试多方法调用
     */
    @Test
    public void testMultipleMethods() {
        Invoker<TestService> invoker = createMockInvoker("test: ");
        TestService proxy = factory.getProxy(invoker);
        
        // 调用多次
        assertEquals("test: msg1", proxy.echo("msg1"));
        assertEquals("test: msg2", proxy.echo("msg2"));
        assertEquals("test: msg3", proxy.echo("msg3"));
    }
    
    /**
     * 测试缓存效率
     */
    @Test
    public void testCacheEfficiency() {
        Invoker<TestService> invoker = createMockInvoker("test");
        
        // 第一次创建（触发字节码生成）
        long start1 = System.nanoTime();
        TestService proxy1 = factory.getProxy(invoker);
        long time1 = System.nanoTime() - start1;
        
        // 第二次创建（缓存命中）
        long start2 = System.nanoTime();
        TestService proxy2 = factory.getProxy(invoker);
        long time2 = System.nanoTime() - start2;
        
        // 验证代理可用
        assertNotNull(proxy1, "First proxy should not be null");
        assertNotNull(proxy2, "Second proxy should not be null");
        
        // 缓存命中后应该快很多
        assertTrue(time1 / time2 > 5, 
            "Cache should be faster, time1=" + time1 + " ns, time2=" + time2 + " ns, speedup=" + (time1 / time2));
        
        System.out.println("First create: " + time1 / 1000 + " μs");
        System.out.println("Cache hit: " + time2 / 1000 + " μs");
        System.out.println("Speed up: " + (time1 / time2) + "x");
    }
    
    /**
     * 测试多接口代理
     */
    @Test
    public void testMultipleInterfaces() {
        Invoker<TestService> invoker = createMockInvoker("multi: ");
        
        // 创建实现多个接口的代理
        Object proxy = factory.getProxy(invoker, new Class<?>[]{
            TestService.class,
            java.io.Serializable.class
        });
        
        // 验证代理实现了所有接口
        assertTrue(proxy instanceof TestService, "Proxy should implement TestService");
        assertTrue(proxy instanceof java.io.Serializable, "Proxy should implement Serializable");
        
        // 验证功能
        assertEquals("multi: test", ((TestService) proxy).echo("test"), 
            "Proxy should work with multiple interfaces");
    }
    
    /**
     * 测试 Object 方法处理
     */
    @Test
    public void testObjectMethods() {
        Invoker<TestService> invoker = createMockInvoker("test");
        TestService proxy = factory.getProxy(invoker);
        
        // toString
        assertNotNull(proxy.toString(), "toString should not return null");
        
        // hashCode
        assertNotEquals(0, proxy.hashCode(), "hashCode should not be 0");
        
        // equals
        assertTrue(proxy.equals(proxy), "Proxy should equal itself");
        assertFalse(proxy.equals(new Object()), "Proxy should not equal other objects");
    }
    
    /**
     * 测试异常处理
     */
    @Test
    public void testExceptionHandling() {
        // 创建抛出异常的 Invoker
        Invoker<TestService> invoker = new Invoker<TestService>() {
            @Override
            public Class<TestService> getInterface() {
                return TestService.class;
            }
            
            @Override
            public Result invoke(Invocation invocation) {
                return new Result(new RuntimeException("Test exception"));
            }
        };
        
        TestService proxy = factory.getProxy(invoker);
        
        // 验证异常传播
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {
            proxy.echo("test");
        });
        
        assertEquals("Test exception", exception.getMessage(), 
            "Exception should be propagated correctly");
    }
    
    /**
     * 测试缓存隔离
     */
    @Test
    public void testCacheIsolation() {
        Invoker<TestService> invoker1 = createMockInvoker("invoker1: ");
        Invoker<AnotherService> invoker2 = createMockInvoker2("invoker2: ");
        
        // 创建不同接口的代理
        TestService proxy1 = factory.getProxy(invoker1);
        AnotherService proxy2 = factory.getProxy(invoker2);
        
        // 验证不同代理相互独立
        assertEquals("invoker1: test", proxy1.echo("test"));
        assertEquals("invoker2: test", proxy2.sayHello("test"));
        
        // 验证是不同的代理类
        assertNotEquals(proxy1.getClass(), proxy2.getClass(), 
            "Different interfaces should have different proxy classes");
    }
    
    // ========== 辅助方法 ==========
    
    /**
     * 创建 Mock Invoker（用于 TestService）
     */
    private Invoker<TestService> createMockInvoker(String prefix) {
        return new Invoker<TestService>() {
            @Override
            public Class<TestService> getInterface() {
                return TestService.class;
            }
            
            @Override
            public Result invoke(Invocation invocation) {
                String methodName = invocation.methodName();
                Object[] args = invocation.arguments();
                
                if ("echo".equals(methodName)) {
                    Object result = prefix + args[0];
                    return new Result(result);
                }
                
                return new Result("unknown");
            }
            
            @Override
            public String toString() {
                return "MockInvoker[TestService]";
            }
            
            @Override
            public int hashCode() {
                return 12345;
            }
        };
    }
    
    /**
     * 创建 Mock Invoker（用于 AnotherService）
     */
    private Invoker<AnotherService> createMockInvoker2(String prefix) {
        return new Invoker<AnotherService>() {
            @Override
            public Class<AnotherService> getInterface() {
                return AnotherService.class;
            }
            
            @Override
            public Result invoke(Invocation invocation) {
                String methodName = invocation.methodName();
                Object[] args = invocation.arguments();
                
                if ("sayHello".equals(methodName)) {
                    Object result = prefix + args[0];
                    return new Result(result);
                }
                
                return new Result("unknown");
            }
        };
    }
    
    // ========== 测试接口 ==========
    
    /**
     * 测试服务接口
     */
    public interface TestService {
        String echo(String msg);
    }
    
    /**
     * 另一个测试服务接口
     */
    public interface AnotherService {
        String sayHello(String name);
    }
}
